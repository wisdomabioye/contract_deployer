// describe the contract and features in a sentence or two.
export const description = "Standard ERC1155 NFT token, supports gasless listing on Opensea and anyone can mint asset. Read more https://adr.pw/kfmrob";

/**
 * @description ContractProps
 * Define the interface for the contract constructor parameters
*/
export interface ContractProps  {
    name: string;
    symbol: string;
    contractURI: string;
    baseMetadataURI: string;
}

/**
 * @description contractFields
 * Define the input fields for the contract constructor as defined in the interface `ContractProps`
 * Each field will be collected from the front end and passed to the constructor on deployment
* The order of the fields in the array is the order in which they will be passed to the contract constructor 
*/
export const contractFields = [
    {name: "name", type: "text", label: "Token name e.g Cookie Project", placeholder: "Enter token name", solType: "string"},
    {name: "symbol", type: "text", label: "Token symbol e.g CKP", placeholder: "Enter token symbol", solType: "string"},
    {name: "contractURI", type: "url", label: "Contract URI e.g https://adr.pw/about", placeholder: "Enter Contract URI", solType: "string"},
    {name: "baseMetadataURI", type: "url", label: "Token metadata URI e.g https://adr.pw/token/", placeholder: "Enter token metadata URI", solType: "string"},
 ];


/**
 * @description contractCode
 * @param {string} contractName is the name of the main contract that'll be deployed to the blockchain
 * The contractName will be passed to the contractCode function.
 * The contractName will be generated from the user input.
 * Providing a contractName will prevent block explorer from showing "Source code match" under the contract tab
 */
 export function contractCode (contractName: string) {

    return (
    `
    // SPDX-License-Identifier: MIT
    pragma solidity 0.8.15;
    
    /**
     * @dev Wrappers over Solidity's arithmetic operations with added overflow
     * checks.
     *
     * Arithmetic operations in Solidity wrap on overflow. This can easily result
     * in bugs, because programmers usually assume that an overflow raises an
     * error, which is the standard behavior in high level programming languages.
     * 'SafeMath' restores this intuition by reverting the transaction when an
     * operation overflows.
     *
     * Using this library instead of the unchecked operations eliminates an entire
     * class of bugs, so it's recommended to use it always.
     */
    library SafeMath {
        /**
         * @dev Returns the addition of two unsigned integers, reverting on
         * overflow.
         *
         * Counterpart to Solidity's '+' operator.
         *
         * Requirements:
         *
         * - Addition cannot overflow.
         */
        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            require(c >= a, "SafeMath: addition overflow");
    
            return c;
        }
    
        /**
         * @dev Returns the subtraction of two unsigned integers, reverting on
         * overflow (when the result is negative).
         *
         * Counterpart to Solidity's '-' operator.
         *
         * Requirements:
         *
         * - Subtraction cannot overflow.
         */
        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            return sub(a, b, "SafeMath: subtraction overflow");
        }
    
        /**
         * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
         * overflow (when the result is negative).
         *
         * Counterpart to Solidity's '-' operator.
         *
         * Requirements:
         *
         * - Subtraction cannot overflow.
         */
        function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
            require(b <= a, errorMessage);
            uint256 c = a - b;
    
            return c;
        }
    
        /**
         * @dev Returns the multiplication of two unsigned integers, reverting on
         * overflow.
         *
         * Counterpart to Solidity's '*' operator.
         *
         * Requirements:
         *
         * - Multiplication cannot overflow.
         */
        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) {
                return 0;
            }
    
            uint256 c = a * b;
            require(c / a == b, "SafeMath: multiplication overflow");
    
            return c;
        }
    
        /**
         * @dev Returns the integer division of two unsigned integers. Reverts on
         * division by zero. The result is rounded towards zero.
         *
         * Counterpart to Solidity's '/' operator. Note: this function uses a
         * 'revert' opcode (which leaves remaining gas untouched) while Solidity
         * uses an invalid opcode to revert (consuming all remaining gas).
         *
         * Requirements:
         *
         * - The divisor cannot be zero.
         */
        function div(uint256 a, uint256 b) internal pure returns (uint256) {
            return div(a, b, "SafeMath: division by zero");
        }
    
        /**
         * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
         * division by zero. The result is rounded towards zero.
         *
         * Counterpart to Solidity's '/' operator. Note: this function uses a
         * 'revert' opcode (which leaves remaining gas untouched) while Solidity
         * uses an invalid opcode to revert (consuming all remaining gas).
         *
         * Requirements:
         *
         * - The divisor cannot be zero.
         */
        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
            require(b > 0, errorMessage);
            uint256 c = a / b;
            // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    
            return c;
        }
    
        /**
         * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
         * Reverts when dividing by zero.
         *
         * Counterpart to Solidity's '%' operator. This function uses a 'revert'
         * opcode (which leaves remaining gas untouched) while Solidity uses an
         * invalid opcode to revert (consuming all remaining gas).
         *
         * Requirements:
         *
         * - The divisor cannot be zero.
         */
        function mod(uint256 a, uint256 b) internal pure returns (uint256) {
            return mod(a, b, "SafeMath: modulo by zero");
        }
    
        /**
         * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
         * Reverts with custom message when dividing by zero.
         *
         * Counterpart to Solidity's '%' operator. This function uses a 'revert'
         * opcode (which leaves remaining gas untouched) while Solidity uses an
         * invalid opcode to revert (consuming all remaining gas).
         *
         * Requirements:
         *
         * - The divisor cannot be zero.
         */
        function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
            require(b != 0, errorMessage);
            return a % b;
        }
    }
    
    /**
     * @dev Collection of functions related to the address type
     */
    library Address {
        /**
         * @dev Returns true if 'account' is a contract.
         *
         * [IMPORTANT]
         * ====
         * It is unsafe to assume that an address for which this function returns
         * false is an externally-owned account (EOA) and not a contract.
         *
         * Among others, 'isContract' will return false for the following
         * types of addresses:
         *
         *  - an externally-owned account
         *  - a contract in construction
         *  - an address where a contract will be created
         *  - an address where a contract lived, but was destroyed
         * ====
         */
        function isContract(address account) internal view returns (bool) {
            // This method relies in extcodesize, which returns 0 for contracts in
            // construction, since the code is only stored at the end of the
            // constructor execution.

            uint256 size;
            // solhint-disable-next-line no-inline-assembly
            assembly { size := extcodesize(account) }
            return size > 0;
        }

        /**
         * @dev Replacement for Solidity's 'transfer': sends 'amount' wei to
         * 'recipient', forwarding all available gas and reverting on errors.
         *
         * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
         * of certain opcodes, possibly making contracts go over the 2300 gas limit
         * imposed by 'transfer', making them unable to receive funds via
         * 'transfer'. {sendValue} removes this limitation.
         *
         * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
         *
         * IMPORTANT: because control is transferred to 'recipient', care must be
         * taken to not create reentrancy vulnerabilities. Consider using
         * {ReentrancyGuard} or the
         * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
         */
        function sendValue(address payable recipient, uint256 amount) internal {
            require(address(this).balance >= amount, "Address: insufficient balance");

            // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
            (bool success, ) = recipient.call{ value: amount }("");
            require(success, "Address: unable to send value, recipient may have reverted");
        }

        /**
         * @dev Performs a Solidity function call using a low level 'call'. A
         * plain'call' is an unsafe replacement for a function call: use this
         * function instead.
         *
         * If 'target' reverts with a revert reason, it is bubbled up by this
         * function (like regular Solidity function calls).
         *
         * Returns the raw returned data. To convert to the expected return value,
         * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions['abi.decode'].
         *
         * Requirements:
         *
         * - 'target' must be a contract.
         * - calling 'target' with 'data' must not revert.
         *
         * _Available since v3.1._
         */
        function functionCall(address target, bytes memory data) internal returns (bytes memory) {
            return functionCall(target, data, "Address: low-level call failed");
        }

        /**
         * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'], but with
         * 'errorMessage' as a fallback revert reason when 'target' reverts.
         *
         * _Available since v3.1._
         */
        function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
            return _functionCallWithValue(target, data, 0, errorMessage);
        }

        /**
         * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'],
         * but also transferring 'value' wei to 'target'.
         *
         * Requirements:
         *
         * - the calling contract must have an ETH balance of at least 'value'.
         * - the called Solidity function must be 'payable'.
         *
         * _Available since v3.1._
         */
        function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
            return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
        }

        /**
         * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}['functionCallWithValue'], but
         * with 'errorMessage' as a fallback revert reason when 'target' reverts.
         *
         * _Available since v3.1._
         */
        function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
            require(address(this).balance >= value, "Address: insufficient balance for call");
            return _functionCallWithValue(target, data, value, errorMessage);
        }

        function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
            require(isContract(target), "Address: call to non-contract");

            // solhint-disable-next-line avoid-low-level-calls
            (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
            if (success) {
                return returndata;
            } else {
                // Look for revert reason and bubble it up if present
                if (returndata.length > 0) {
                    // The easiest way to bubble the revert reason is using memory via assembly

                    // solhint-disable-next-line no-inline-assembly
                    assembly {
                        let returndata_size := mload(returndata)
                        revert(add(32, returndata), returndata_size)
                    }
                } else {
                    revert(errorMessage);
                }
            }
        }
    }

    /**
     * @title ERC20 interface
     * @dev see https://eips.ethereum.org/EIPS/eip-20
     */
    interface IERC20 {
        function transfer(address to, uint256 value) external returns (bool);
        function approve(address spender, uint256 value) external returns (bool);
        function transferFrom(address from, address to, uint256 value) external returns (bool);
        function totalSupply() external view returns (uint256);
        function balanceOf(address who) external view returns (uint256);
        function allowance(address owner, address spender) external view returns (uint256);
        event Transfer(address indexed from, address indexed to, uint256 value);
        event Approval(address indexed owner, address indexed spender, uint256 value);
    }

    /**
     * @title ERC165
     * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md
     */
    interface IERC165 {

        /**
         * @notice Query if a contract implements an interface
         * @dev Interface identification is specified in ERC-165. This function
         * uses less than 30,000 gas
         * @param _interfaceId The interface identifier, as specified in ERC-165
         */
        function supportsInterface(bytes4 _interfaceId)
        external
        view
        returns (bool);
    }

    /**
     * @dev ERC-1155 interface for accepting safe transfers.
     */
    interface IERC1155TokenReceiver {

        /**
         * @notice Handle the receipt of a single ERC1155 token type
         * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a 'safeTransferFrom' after the balance has been updated
         * This function MAY throw to revert and reject the transfer
         * Return of other amount than the magic value MUST result in the transaction being reverted
         * Note: The token contract address is always the message sender
         * @param _operator  The address which called the 'safeTransferFrom' function
         * @param _from      The address which previously owned the token
         * @param _id        The id of the token being transferred
         * @param _amount    The amount of tokens being transferred
         * @param _data      Additional data with no specified format
         * @return           'bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))'
         */
        function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);

        /**
         * @notice Handle the receipt of multiple ERC1155 token types
         * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a 'safeBatchTransferFrom' after the balances have been updated
         * This function MAY throw to revert and reject the transfer
         * Return of other amount than the magic value WILL result in the transaction being reverted
         * Note: The token contract address is always the message sender
         * @param _operator  The address which called the 'safeBatchTransferFrom' function
         * @param _from      The address which previously owned the token
         * @param _ids       An array containing ids of each token being transferred
         * @param _amounts   An array containing amounts of each token being transferred
         * @param _data      Additional data with no specified format
         * @return           'bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))'
         */
        function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);
    }

    interface IERC1155 {

        /****************************************|
        |                 Events                 |
        |_______________________________________*/
        
        /**
         * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning
         *   Operator MUST be msg.sender
         *   When minting/creating tokens, the '_from' field MUST be set to '0x0'
         *   When burning/destroying tokens, the '_to' field MUST be set to '0x0'
         *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID
         *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from '0x0' to '0x0', with the token creator as '_operator', and a '_amount' of 0
         */
        event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);
        
        /**
         * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning
         *   Operator MUST be msg.sender
         *   When minting/creating tokens, the '_from' field MUST be set to '0x0'
         *   When burning/destroying tokens, the '_to' field MUST be set to '0x0'
         *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID
         *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from '0x0' to '0x0', with the token creator as '_operator', and a '_amount' of 0
         */
        event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);
        
        /**
         * @dev MUST emit when an approval is updated
         */
        event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
        
        
        /****************************************|
        |                Functions               |
        |_______________________________________*/
        
        /**
         * @notice Transfers amount of an _id from the _from address to the _to address specified
         * @dev MUST emit TransferSingle event on success
         * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)
         * MUST throw if '_to' is the zero address
         * MUST throw if balance of sender for token '_id' is lower than the '_amount' sent
         * MUST throw on any other error
         * When transfer is complete, this function MUST check if '_to' is a smart contract (code size > 0). If so, it MUST call 'onERC1155Received' on '_to' and revert if the return amount is not 'bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))'
         * @param _from    Source address
         * @param _to      Target address
         * @param _id      ID of the token type
         * @param _amount  Transfered amount
         * @param _data    Additional data with no specified format, sent in call to '_to'
         */
        function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;
        
        /**
             * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)
             * @dev MUST emit TransferBatch event on success
             * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)
             * MUST throw if '_to' is the zero address
             * MUST throw if length of '_ids' is not the same as length of '_amounts'
             * MUST throw if any of the balance of sender for token '_ids' is lower than the respective '_amounts' sent
             * MUST throw on any other error
             * When transfer is complete, this function MUST check if '_to' is a smart contract (code size > 0). If so, it MUST call 'onERC1155BatchReceived' on '_to' and revert if the return amount is not 'bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))'
             * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)
             * @param _from     Source addresses
             * @param _to       Target addresses
             * @param _ids      IDs of each token type
             * @param _amounts  Transfer amounts per token type
             * @param _data     Additional data with no specified format, sent in call to '_to'
        */
        function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;
        
        /**
         * @notice Get the balance of an account's Tokens
         * @param _owner  The address of the token holder
         * @param _id     ID of the Token
         * @return        The _owner's balance of the Token type requested
         */
        function balanceOf(address _owner, uint256 _id) external view returns (uint256);
        
        /**
         * @notice Get the balance of multiple account/token pairs
         * @param _owners The addresses of the token holders
         * @param _ids    ID of the Tokens
         * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)
         */
        function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);
        
        /**
         * @notice Enable or disable approval for a third party ("operator") to manage all of caller's tokens
         * @dev MUST emit the ApprovalForAll event on success
         * @param _operator  Address to add to the set of authorized operators
         * @param _approved  True if the operator is approved, false to revoke approval
         */
        function setApprovalForAll(address _operator, bool _approved) external;
        
        /**
         * @notice Queries the approval status of an operator for a given owner
         * @param _owner     The owner of the Tokens
         * @param _operator  Address of authorized operator
         * @return isOperator True if the operator is approved, false if not
         */
        function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);
    }

    interface IERC1155Metadata {

        event URI(string _uri, uint256 indexed _id);
        
        /****************************************|
        |                Functions               |
        |_______________________________________*/
        
        /**
         * @notice A distinct Uniform Resource Identifier (URI) for a given token.
         * @dev URIs are defined in RFC 3986.
         *      URIs are assumed to be deterministically generated based on token ID
         *      Token IDs are assumed to be represented in their hex format in URIs
         * @return URI string
         */
        function uri(uint256 _id) external view returns (string memory);
    }

    /**
     * @title Ownable
     * @dev The Ownable contract has an owner address, and provides basic authorization control
     * functions, this simplifies the implementation of "user permissions".
     */
    contract Ownable {
        address private _owner_;

        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

        /**
         * @dev The Ownable constructor sets the original 'owner' of the contract to the sender
         * account.
         */
        constructor () {
            _owner_ = msg.sender;
            emit OwnershipTransferred(address(0), _owner_);
        }

        /**
         * @dev Throws if called by any account other than the owner.
         */
        modifier onlyOwner() {
            require(msg.sender == _owner_, "Ownable#onlyOwner: SENDER_IS_NOT_OWNER");
            _;
        }

        /**
         * @notice Transfers the ownership of the contract to new address
         * @param _newOwner Address of the new owner
         */
        function transferOwnership(address _newOwner) public onlyOwner {
            require(_newOwner != address(0), "Ownable#transferOwnership: INVALID_ADDRESS");
            emit OwnershipTransferred(_owner_, _newOwner);
            _owner_ = _newOwner;
        }

        /**
         * @notice Returns the address of the owner.
         */
        function owner() public view returns (address) {
            return _owner_;
        }
    }

    contract OwnableDelegateProxy { }

    contract ProxyRegistry {
        mapping(address => OwnableDelegateProxy) public proxies;
    }

    contract ERC165 is IERC165 {
        /**
         * @notice Query if a contract implements an interface
         * @param _interfaceID The interface identifier, as specified in ERC-165
         * @return 'true' if the contract implements '_interfaceID'
         */
        function supportsInterface(bytes4 _interfaceID) virtual override public pure returns (bool) {
            return _interfaceID == this.supportsInterface.selector;
        }
    }


    /**
     * @notice Contract that handles metadata related methods.
     * @dev Methods assume a deterministic generation of URI based on token IDs.
     *      Methods also assume that URI uses hex representation of token IDs.
     */
    contract ERC1155Metadata is IERC1155Metadata, ERC165 {
        // URI's default URI prefix
        string internal baseMetadataURI;

        /***********************************|
         |     Metadata Public Function s    |
        |__________________________________*/

        /**
         * @notice A distinct Uniform Resource Identifier (URI) for a given token.
         * @dev URIs are defined in RFC 3986.
         *      URIs are assumed to be deterministically generated based on token ID
         * @return URI string
         */
        function uri(uint256 _id) public override view returns (string memory) {
            return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), ".json"));
        }

        /***********************************|
         |    Metadata Internal Functions    |
        |__________________________________*/

        /**
         * @notice Will emit default URI log event for corresponding token _id
         * @param _tokenIDs Array of IDs of tokens to log default URI
         */
        function _logURIs(uint256[] memory _tokenIDs) internal {
            string memory baseURL = baseMetadataURI;
            string memory tokenURI;

            for (uint256 i = 0; i < _tokenIDs.length; i++) {
            tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), ".json"));
            emit URI(tokenURI, _tokenIDs[i]);
            }
        }

        /**
         * @notice Will update the base URL of token's URI
         * @param _newBaseMetadataURI New base URL of token's URI
         */
        function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {
            baseMetadataURI = _newBaseMetadataURI;
        }

        /**
         * @notice Query if a contract implements an interface
         * @param _interfaceID  The interface identifier, as specified in ERC-165
         * @return 'true' if the contract implements '_interfaceID' and
         */
        function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {
            if (_interfaceID == type(IERC1155Metadata).interfaceId) {
            return true;
            }
            return super.supportsInterface(_interfaceID);
        }


        /***********************************|
         |    Utility Internal Functions     |
        |__________________________________*/

        /**
         * @notice Convert uint256 to string
         * @param _i Unsigned integer to convert to string
         */
        function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {
            if (_i == 0) {
            return "0";
            }

            uint256 j = _i;
            uint256 ii = _i;
            uint256 len;

            // Get number of bytes
            while (j != 0) {
            len++;
            j /= 10;
            }

            bytes memory bstr = new bytes(len);
            uint256 k = len - 1;

            // Get each individual ASCII
            while (ii != 0) {
            bstr[k--] = bytes1(uint8(48 + ii % 10));
            ii /= 10;
            }

            // Convert to string
            return string(bstr);
        }
        }

    /**
     * @dev Implementation of Multi-Token Standard contract
     */
    contract ERC1155 is IERC1155, ERC165, ERC1155Metadata {
        using SafeMath for uint256;
        using Address for address;

        /***********************************|
         |        Variables and Events       |
        |__________________________________*/

        // onReceive function signatures
        bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;
        bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;

        // Objects balances
        mapping (address => mapping(uint256 => uint256)) internal balances;

        // Operator Functions
        mapping (address => mapping(address => bool)) internal operators;


        /***********************************|
         |     Public Transfer Functions     |
        |__________________________________*/

        /**
         * @notice Transfers amount amount of an _id from the _from address to the _to address specified
         * @param _from    Source address
         * @param _to      Target address
         * @param _id      ID of the token type
         * @param _amount  Transfered amount
         * @param _data    Additional data with no specified format, sent in call to '_to'
         */
        function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data) public override {
            require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155#safeTransferFrom: INVALID_OPERATOR");
            require(_to != address(0),"ERC1155#safeTransferFrom: INVALID_RECIPIENT");
            // require(_amount <= balances[_from][_id]) is not necessary since checked with safemath operations

            _safeTransferFrom(_from, _to, _id, _amount);
            _callonERC1155Received(_from, _to, _id, _amount, gasleft(), _data);
        }

        /**
         * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)
         * @param _from     Source addresses
         * @param _to       Target addresses
         * @param _ids      IDs of each token type
         * @param _amounts  Transfer amounts per token type
         * @param _data     Additional data with no specified format, sent in call to '_to'
         */
        function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) public override {
            // Requirements
            require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155#safeBatchTransferFrom: INVALID_OPERATOR");
            require(_to != address(0), "ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT");

            _safeBatchTransferFrom(_from, _to, _ids, _amounts);
            _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasleft(), _data);
        }


        /***********************************|
         |    Internal Transfer Functions    |
        |__________________________________*/

        /**
         * @notice Transfers amount amount of an _id from the _from address to the _to address specified
         * @param _from    Source address
         * @param _to      Target address
         * @param _id      ID of the token type
         * @param _amount  Transfered amount
         */
        function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount) internal {
            // Update balances
            balances[_from][_id] = balances[_from][_id].sub(_amount); // Subtract amount
            balances[_to][_id] = balances[_to][_id].add(_amount);     // Add amount

            // Emit event
            emit TransferSingle(msg.sender, _from, _to, _id, _amount);
        }

        /**
         * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)
         */
        function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, uint256 _gasLimit, bytes memory _data) internal {
            // Check if recipient is contract
            if (_to.isContract()) {
            bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received{gas: _gasLimit}(msg.sender, _from, _id, _amount, _data);
            require(retval == ERC1155_RECEIVED_VALUE, "ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE");
            }
        }

        /**
         * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)
         * @param _from     Source addresses
         * @param _to       Target addresses
         * @param _ids      IDs of each token type
         * @param _amounts  Transfer amounts per token type
         */
        function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts) internal {
            require(_ids.length == _amounts.length, "ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH");

            // Number of transfer to execute
            uint256 nTransfer = _ids.length;

            // Executing all transfers
            for (uint256 i = 0; i < nTransfer; i++) {
            // Update storage balance of previous bin
            balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);
            balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);
            }

            // Emit event
            emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);
        }

        /**
         * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)
         */
        function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, uint256 _gasLimit, bytes memory _data) internal {
            // Pass data if recipient is contract
            if (_to.isContract()) {
            bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived{gas: _gasLimit}(msg.sender, _from, _ids, _amounts, _data);
            require(retval == ERC1155_BATCH_RECEIVED_VALUE, "ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE");
            }
        }


        /***********************************|
         |         Operator Functions        |
        |__________________________________*/

        /**
         * @notice Enable or disable approval for a third party ("operator") to manage all of caller's tokens
         * @param _operator  Address to add to the set of authorized operators
         * @param _approved  True if the operator is approved, false to revoke approval
         */
        function setApprovalForAll(address _operator, bool _approved) external override {
            // Update operator status
            operators[msg.sender][_operator] = _approved;
            emit ApprovalForAll(msg.sender, _operator, _approved);
        }

        /**
         * @notice Queries the approval status of an operator for a given owner
         * @param _owner     The owner of the Tokens
         * @param _operator  Address of authorized operator
         * @return isOperator True if the operator is approved, false if not
         */
        function isApprovedForAll(address _owner, address _operator) public virtual override view returns (bool isOperator) {
            return operators[_owner][_operator];
        }


        /***********************************|
         |         Balance Functions         |
        |__________________________________*/

        /**
         * @notice Get the balance of an account's Tokens
         * @param _owner  The address of the token holder
         * @param _id     ID of the Token
         * @return The _owner's balance of the Token type requested
         */
        function balanceOf(address _owner, uint256 _id) public override view returns (uint256) {
            return balances[_owner][_id];
        }

        /**
         * @notice Get the balance of multiple account/token pairs
         * @param _owners The addresses of the token holders
         * @param _ids    ID of the Tokens
         * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)
         */
        function balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public override view returns (uint256[] memory) {
            require(_owners.length == _ids.length, "ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH");

            // Variables
            uint256[] memory batchBalances = new uint256[](_owners.length);

            // Iterate over each owner and token ID
            for (uint256 i = 0; i < _owners.length; i++) {
            batchBalances[i] = balances[_owners[i]][_ids[i]];
            }

            return batchBalances;
        }

        /***********************************|
         |          ERC165 Functions         |
        |__________________________________*/

        /**
         * @notice Query if a contract implements an interface
         * @param _interfaceID  The interface identifier, as specified in ERC-165
         * @return 'true' if the contract implements '_interfaceID' and
         */
        function supportsInterface(bytes4 _interfaceID) public override(ERC165, ERC1155Metadata) virtual pure returns (bool) {
            if (_interfaceID == type(IERC1155).interfaceId) {
            return true;
            }
            return super.supportsInterface(_interfaceID);
        }
        }

    /**
     * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume
     *      a parent contract to be executed as they are 'internal' functions
     */
    contract ERC1155MintBurn is ERC1155 {
        using SafeMath for uint256;

        /****************************************|
         |            Minting Functions           |
        |_______________________________________*/

        /**
         * @notice Mint _amount of tokens of a given id
         * @param _to      The address to mint tokens to
         * @param _id      Token id to mint
         * @param _amount  The amount to be minted
         * @param _data    Data to pass if receiver is contract
         */
        function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data) internal {
            // Add _amount
            balances[_to][_id] = balances[_to][_id].add(_amount);

            // Emit event
            emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);

            // Calling onReceive method if recipient is contract
            _callonERC1155Received(address(0x0), _to, _id, _amount, gasleft(), _data);
        }

        /**
         * @notice Mint tokens for each ids in _ids
         * @param _to       The address to mint tokens to
         * @param _ids      Array of ids to mint
         * @param _amounts  Array of amount of tokens to mint per id
         * @param _data    Data to pass if receiver is contract
         */
        function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) internal {
            require(_ids.length == _amounts.length, "ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH");

            // Number of mints to execute
            uint256 nMint = _ids.length;

            // Executing all minting
            for (uint256 i = 0; i < nMint; i++) {
            // Update storage balance
            balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);
            }

            // Emit batch mint event
            emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);

            // Calling onReceive method if recipient is contract
            _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, gasleft(), _data);
        }


        /****************************************|
         |            Burning Functions           |
        |_______________________________________*/

        /**
         * @notice Burn _amount of tokens of a given token id
         * @param _from    The address to burn tokens from
         * @param _id      Token id to burn
         * @param _amount  The amount to be burned
         */
        function _burn(address _from, uint256 _id, uint256 _amount) internal {
            //Substract _amount
            balances[_from][_id] = balances[_from][_id].sub(_amount);

            // Emit event
            emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);
        }

        /**
         * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair
         * @param _from     The address to burn tokens from
         * @param _ids      Array of token ids to burn
         * @param _amounts  Array of the amount to be burned
         */
        function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts) internal {
            // Number of mints to execute
            uint256 nBurn = _ids.length;
            require(nBurn == _amounts.length, "ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH");

            // Executing all minting
            for (uint256 i = 0; i < nBurn; i++) {
            // Update storage balance
            balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);
            }

            // Emit batch mint event
            emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);
        }
    }

    contract ${contractName} is ERC1155MintBurn, Ownable {
        using SafeMath for uint256;
        
        address proxyRegistryAddress;
        uint256 private _currentTokenID = 0;
        mapping (uint256 => address) public creators;
        mapping (uint256 => uint256) public tokenSupply;
        // Contract name
        string public name;
        // Contract symbol
        string public symbol;
        // contract URI
        string private _contractUri;

        /**
         * @dev Require msg.sender to be the creator of the token id
         */
        modifier creatorOnly(uint256 _id) {
            require(creators[_id] == msg.sender, "METAdor#creatorOnly: ONLY_CREATOR_ALLOWED");
            _;
        }

        constructor(string memory _name, string memory _symbol, string memory _contractURI, string memory _baseMetadataURI) {
            name = _name;
            symbol = _symbol;
            _contractUri = _contractURI; // contract info metadata URI
            _setBaseMetadataURI(_baseMetadataURI); // token metadata URI
            proxyRegistryAddress = address(0xF57B2c51dED3A29e6891aba85459d600256Cf317);
        }

        /**
            * @dev Returns the total quantity for a token ID
            * @param _id uint256 ID of the token to query
            * @return amount of token in existence
            */
        function totalSupply(uint256 _id) public view returns (uint256) {
            return tokenSupply[_id];
        }

        /**
         * @dev Will update the base URL of token's URI
         * @param _newBaseMetadataURI New base URL of token's URI
         */
        function setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyOwner {
            _setBaseMetadataURI(_newBaseMetadataURI);
        }

        /**
        * @dev Creates a new token type and assigns _initialSupply to an address
        * @param _initialOwner address of the first owner of the token
        * @param _initialSupply amount to supply the first owner
        * @param _uri Optional URI for this token type
        * @param _data Data to pass if receiver is contract
        * @return The newly created token ID
        */
        function create(address _initialOwner, uint256 _initialSupply, string calldata _uri, bytes calldata _data) external returns (uint256) {
            uint256 _id = _getNextTokenID();
            _incrementTokenTypeId();
            creators[_id] = msg.sender;

            if (bytes(_uri).length > 0) {
            emit URI(_uri, _id);
            }
            _mint(_initialOwner, _id, _initialSupply, _data);
            tokenSupply[_id] = _initialSupply;
            return _id;
        }

        /**
        * @dev Mints some amount of tokens to an address
        * @param _to          Address of the future owner of the token
        * @param _id          Token ID to mint
        * @param _quantity    Amount of tokens to mint
        * @param _data        Data to pass if receiver is contract
        */
        function mint(address _to, uint256 _id, uint256 _quantity, bytes memory _data) public creatorOnly(_id) {
            _mint(_to, _id, _quantity, _data);
            tokenSupply[_id] = tokenSupply[_id].add(_quantity);
        }

        /**
        * @dev Mint tokens for each id in _ids
        * @param _to          The address to mint tokens to
        * @param _ids         Array of ids to mint
        * @param _quantities  Array of amounts of tokens to mint per id
        * @param _data        Data to pass if receiver is contract
        */
        function batchMint(address _to, uint256[] memory _ids, uint256[] memory _quantities, bytes memory _data) public {
            for (uint256 i = 0; i < _ids.length; i++) {
            uint256 _id = _ids[i];
            require(creators[_id] == msg.sender, "METAdor#batchMint: ONLY_CREATOR_ALLOWED");
            uint256 quantity = _quantities[i];
            tokenSupply[_id] = tokenSupply[_id].add(quantity);
            }
            _batchMint(_to, _ids, _quantities, _data);
        }

        /**
         * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.
         */
        function isApprovedForAll(address _owner, address _operator) public override view returns (bool isOperator) {
            // Whitelist OpenSea proxy contract for easy trading.
            ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);
            if (address(proxyRegistry.proxies(_owner)) == _operator) {
            return true;
            }

            return ERC1155.isApprovedForAll(_owner, _operator);
        }
        /*
        * @dev burn _value from token _id
        * @param _id Token ID to burn from
        * @param _value Amount of token to burn
        */
        function burn(uint256 _id, uint256 _value) public {
            _burn(msg.sender, _id, _value);
        }
        
        /**
        * @dev Returns whether the specified token exists by checking to see if it has a creator
        * @param _id uint256 ID of the token to query the existence of
        * @return bool whether the token exists
        */
        function _exists(uint256 _id) internal view returns (bool) {
            return creators[_id] != address(0);
        }

        /**
        * @dev calculates the next token ID based on value of _currentTokenID
        * @return uint256 for the next token ID
        */
        function _getNextTokenID() private view returns (uint256) {
            return _currentTokenID.add(1);
        }

        /**
        * @dev increments the value of _currentTokenID
        */
        function _incrementTokenTypeId() private {
            _currentTokenID++;
        }
        
        /*
        * @dev store front metadata-url
        * @param _newUri The new store metadata-url
        */
        function setContractURI(string calldata _newUri) external onlyOwner {
            _contractUri = _newUri;
        }
        
        /*
        * @dev store front metadata-url
        */
        function contractURI() external view returns (string memory) {
            return _contractUri;
        }
    }
    `
    )
 }